# Field goals attempted
home_field_goal_attempted = field_goals_attempted[team_home_away == "home"],
away_field_goal_attempted = field_goals_attempted[team_home_away == "away"],
field_goal_attempted_diff = home_field_goal_attempted - away_field_goal_attempted,
# Free throws made
home_free_throw_made = free_throws_made[team_home_away == "home"],
away_free_throw_made = free_throws_made[team_home_away == "away"],
free_throw_made_diff = home_free_throw_made - away_free_throw_made,
# Free throws attempted
home_free_throw_attempted = free_throws_attempted[team_home_away == "home"],
away_free_throw_attempted = free_throws_attempted[team_home_away == "away"],
free_throw_attempted_diff = home_free_throw_attempted - away_free_throw_attempted,
# Fouls
home_fouls = fouls[team_home_away == "home"],
away_fouls = fouls[team_home_away == "away"],
foul_diff = home_fouls - away_fouls,
# Total turnovers
home_tot_turnover = total_turnovers[team_home_away == "home"],
away_tot_turnover = total_turnovers[team_home_away == "away"],
tot_turnover_diff = home_tot_turnover - away_tot_turnover,
# Three-point pct
home_three_point_pct = three_point_field_goal_pct[team_home_away == "home"],
away_three_point_pct = three_point_field_goal_pct[team_home_away == "away"],
three_point_pct_diff = home_three_point_pct - away_three_point_pct,
# Fast break point
home_fast_break_pt = fast_break_points[team_home_away == "home"],
away_fast_break_pt = fast_break_points[team_home_away == "away"],
fast_break_pt_diff = home_fast_break_pt - away_fast_break_pt,
# Point in the paint
home_pt_in_paint = points_in_paint[team_home_away == "home"],
away_pt_in_paint = points_in_paint[team_home_away == "away"],
pt_in_paint_diff = home_pt_in_paint - away_pt_in_paint,
# Largest lead
home_largest_lead = largest_lead[team_home_away == "home"],
away_largest_lead = largest_lead[team_home_away == "away"],
largest_lead_diff = home_largest_lead - away_largest_lead
) %>%
ungroup()
nba <- nba %>%
mutate(
home_fg_pct = if_else(home_field_goal_attempted > 0,
home_field_goal_made / home_field_goal_attempted,
NA_real_),
away_fg_pct = if_else(away_field_goal_attempted > 0,
away_field_goal_made / away_field_goal_attempted,
NA_real_),
fg_pct_diff = home_fg_pct - away_fg_pct,
home_ft_pct = if_else(home_free_throw_attempted > 0,
home_free_throw_made / home_free_throw_attempted,
NA_real_),
away_ft_pct = if_else(away_free_throw_attempted > 0,
away_free_throw_made / away_free_throw_attempted,
NA_real_),
ft_pct_diff = home_ft_pct - away_ft_pct,
# Total rebounds (from def + off)
home_tot_reb = home_def_reb + home_off_reb,
away_tot_reb = away_def_reb + away_off_reb,
tot_reb_diff = home_tot_reb - away_tot_reb,
# Aliases to match your modeling names
to_diff        = tot_turnover_diff,
paint_pt_diff  = pt_in_paint_diff
) %>%
drop_na()
##### 3. MODELING DATA FRAME (ONLY DIFFS) #####
nba_model <- nba %>%
select(
game_id,
score_diff,
to_diff,              # turnovers diff
tot_reb_diff,         # total rebounds diff
block_diff,
foul_diff,
assist_diff,
fg_pct_diff,
ft_pct_diff,
three_point_pct_diff,
fast_break_pt_diff,
largest_lead_diff,
paint_pt_diff         # points in paint diff
)
##### 4. QUICK EDA #####
summary(nba_model)
ggplot(nba_model, aes(x = score_diff)) +
geom_histogram(bins = 30) +
labs(title = "Distribution of Score Differential (Home - Away)")
nba_numeric <- nba_model %>% select(-game_id)
GGally::ggcorr(nba_numeric, label = TRUE)
##### 5. TRAIN / TEST SPLIT #####
set.seed(123)
split <- initial_split(nba_model, prop = 0.8)
nba_train <- training(split)
nba_test  <- testing(split)
##### 6. MULTIPLE LINEAR REGRESSION (MLR) #####
mlr_fit <- lm(score_diff ~ .,
data = nba_train %>% select(-game_id))
summary(mlr_fit)
test_preds <- predict(mlr_fit, nba_test)
test_mse <- mean((test_preds - nba_test$score_diff)^2)
test_mse
##### 7. 5-FOLD CROSS-VALIDATION MSE #####
set.seed(123)
folds <- vfold_cv(nba_train, v = 5)
cv_results <- folds %>%
mutate(
model = map(splits, ~ lm(score_diff ~ .,
data = analysis(.x) %>% select(-game_id))),
mse = map2_dbl(model, splits, ~ {
valid <- assessment(.y)
preds <- predict(.x, newdata = valid)
mean((preds - valid$score_diff)^2)
})
)
cv_results
mean_cv_mse <- mean(cv_results$mse)
mean_cv_mse
par(mfrow = c(2, 2))
plot(mlr_fit)
par(mfrow = c(1, 1))
knitr::opts_chunk$set(echo = TRUE)
library(alr4)
data(sleep1)
m1 <- nls(TS~ b0 + b11*((D==1)*(log(BodyWt) - gamma))
+ b12*((D==2)*(log(BodyWt) - gamma))
+ b13*((D==3)*(log(BodyWt) - gamma))
+ b14*((D==4)*(log(BodyWt) - gamma))
+ b15*((D==5)*(log(BodyWt) - gamma)),
data=sleep1,
start=list(b0=11,b11=-.3,b12=-.6,b13=-.9,b14=-.6,
b15=-1.6, gamma=0))
summary(m1)
library(alr4)
data(sleep1)
model1 <- lm(TS ~ log(BodyWt):factor(D), sleep1)
summary(model1)$coef
model2 <- nls(TS~ b0 + b11*((D==1)*(log(BodyWt) - gamma))
+ b12*((D==2)*(log(BodyWt) - gamma))
+ b13*((D==3)*(log(BodyWt) - gamma))
+ b14*((D==4)*(log(BodyWt) - gamma))
+ b15*((D==5)*(log(BodyWt) - gamma)),
data=sleep1,
start=list(b0=11,b11=-.3,b12=-.6,b13=-.9,b14=-.6,
b15=-1.6, gamma=0))
summary(model2)
library(alr4)
data(sleep1)
model1 <- lm(TS ~ log(BodyWt):factor(D), data = sleep1)
summary(model1)$coef
model2 <- nls(TS~ b0 + b11*((D==1)*(log(BodyWt) -gamma))
+ b12*((D==2)*(log(BodyWt) - gamma)) + b13*((D==3)*(log(BodyWt) - gamma))
+ b14*((D==4)*(log(BodyWt) - gamma)) + b15*((D==5)*(log(BodyWt) - gamma)), data=sleep1,
start=list(b0 = 11,b11 = -0.3, b12 = -0.6, b13 = -0.9, b14 = -0.6, b15 = -1.6, gamma=0))
summary(model2)
knitr::opts_chunk$set(echo = TRUE)
library(alr4)
data(sleep1)
model1 <- lm(TS ~ log(BodyWt):factor(D), data = sleep1)
summary(model1)$coef
model2 <- nls(TS~ b0 + b11*((D==1)*(log(BodyWt) -gamma))
+ b12*((D==2)*(log(BodyWt) - gamma)) + b13*((D==3)*(log(BodyWt) - gamma))
+ b14*((D==4)*(log(BodyWt) - gamma)) + b15*((D==5)*(log(BodyWt) - gamma)), data=sleep1,
start=list(b0 = 11,b11 = -0.3, b12 = -0.6, b13 = -0.9, b14 = -0.6, b15 = -1.6, gamma=0))
summary(model2)
xml2::read_html("/Users/rudraksh/Downloads/Project625 (1).html")
knitr::opts_chunk$set(echo = TRUE)
# 1. Define the Transition Matrix P (from Problem 2)
# Rows must sum to 1.
# Row 1: 1->1 (0.5), 1->2 (0.5), 1->3 (0)
# Row 2: 2->1 (0.5), 2->2 (0),   2->3 (0.5)
# Row 3: 3->1 (1/3), 3->2 (1/3), 3->3 (1/3) [The fixed dead-end]
P <- matrix(c(0.5, 0.5, 0,
0.5, 0,   0.5,
1/3, 1/3, 1/3),
nrow = 3, byrow = TRUE)
# Function to compute PageRank
calculate_pagerank <- function(P, beta) {
N <- nrow(P)
# Create the Teleportation Matrix J (1/N everywhere)
J <- matrix(1/N, nrow = N, ncol = N)
# Create the Google Matrix G
# G = beta * P + (1 - beta) * J
G <- beta * P + (1 - beta) * J
# Solve for the stationary distribution pi such that pi * G = pi.
# In R, eigen() finds right eigenvectors (A*x = lambda*x).
# We need the left eigenvector (x*G = x), which is equivalent to
# the right eigenvector of the transpose of G (t(G)).
e <- eigen(t(G))
# Extract the eigenvector corresponding to the eigenvalue closest to 1
# (The first eigenvalue is always 1 for stochastic matrices)
v <- Re(e$vectors[,1])
# Normalize the vector so it sums to 1 (to make it a valid probability distribution)
pageranks <- v / sum(v)
return(pageranks)
}
# --- Case 1: Beta = 1 ---
# This checks your answer to Problem 2
pr_beta_1 <- calculate_pagerank(P, beta = 1)
print("PageRanks for Beta = 1:")
print(pr_beta_1)
# Verification against manual calculation [6/13, 4/13, 3/13]
manual_calc <- c(6/13, 4/13, 3/13)
print("Manual Calculation (verification):")
print(manual_calc)
# --- Case 2: Beta = 0.85 ---
# This is the standard PageRank
pr_beta_085 <- calculate_pagerank(P, beta = 0.85)
print("PageRanks for Beta = 0.85:")
print(pr_beta_085)
P <- matrix(c(0.5, 0.5, 0,
0.5, 0,   0.5,
1/3, 1/3, 1/3),
nrow = 3, byrow = TRUE)
calculate_pagerank <- function(P, beta) {
N <- nrow(P)
J <- matrix(1/N, nrow = N, ncol = N)
G <- beta * P + (1 - beta) * J
e <- eigen(t(G))
v <- Re(e$vectors[,1])
pageranks <- v / sum(v)
return(pageranks)}
# Case1 when Beta = 1
pr_beta_1 <- calculate_pagerank(P, 1)
print("PageRanks for Beta = 1:")
print(pr_beta_1)
# Verify against my result from part 2
manual_calc <- c(6/13, 4/13, 3/13)
print("Manual Calculation (verification):")
print(manual_calc)
# Case2 when Beta = 0.85
pr_beta_085 <- calculate_pagerank(P, 0.85)
print("PageRanks for Beta = 0.85:")
print(pr_beta_085)
P <- matrix(c(0.5, 0.5, 0,
0.5, 0,   0.5,
1/3, 1/3, 1/3),
nrow = 3, byrow = TRUE)
calculate_pagerank <- function(P, beta) {
N <- nrow(P)
J <- matrix(1/N, nrow = N, ncol = N)
G <- beta * P + (1 - beta) * J
e <- eigen(t(G))
v <- Re(e$vectors[,1])
pageranks <- v / sum(v)
return(pageranks)}
# Case1 when Beta = 1
pr_beta_1 <- calculate_pagerank(P, 1)
print("PageRanks for Beta = 1:")
print(pr_beta_1)
# Verify against my result from part 2
manual_calc <- c(6/13, 4/13, 3/13)
print("Result for Manual solving from part 2:")
print(manual_calc)
# Case2 when Beta = 0.85
pr_beta_085 <- calculate_pagerank(P, 0.85)
print("PageRanks for Beta = 0.85:")
print(pr_beta_085)
P <- matrix(c(0.5, 0.5, 0,
0.5, 0,   0.5,
1/3, 1/3, 1/3),
nrow = 3, byrow = TRUE)
calculate_pagerank <- function(P, beta) {
N <- nrow(P)
J <- matrix(1/N, nrow = N, ncol = N)
G <- beta * P + (1 - beta) * J
e <- eigen(t(G))
v <- Re(e$vectors[,1])
pageranks <- v / sum(v)
return(pageranks)}
# Case1 when Beta = 1
pr_beta_1 <- calculate_pagerank(P, 1)
print("PageRanks for Beta = 1:")
print(pr_beta_1)
# Case2 when Beta = 0.85
pr_beta_085 <- calculate_pagerank(P, 0.85)
print("PageRanks for Beta = 0.85:")
print(pr_beta_085)
# Verify against my result from part 2
manual_calc <- c(6/13, 4/13, 3/13)
print("Result for Manual solving from part 2:")
print(manual_calc)
P <- matrix(c(0.5, 0.5, 0,
0.5, 0,   0.5,
1/3, 1/3, 1/3),
nrow = 3, byrow = TRUE)
calculate_pagerank <- function(P, beta) {
N <- nrow(P)
J <- matrix(1/N, nrow = N, ncol = N)
G <- beta * P + (1 - beta) * J
e <- eigen(t(G))
v <- Re(e$vectors[,1])
pageranks <- v / sum(v)
return(pageranks)}
# Case1 when Beta = 1
pr_beta_1 <- calculate_pagerank(P, 1)
print("PageRanks for Beta = 1:")
print(pr_beta_1)
# Case2 when Beta = 0.85
pr_beta_085 <- calculate_pagerank(P, 0.85)
print("PageRanks for Beta = 0.85:")
print(pr_beta_085)
# Verify against my result from part 2
manual_calc <- c(6/13, 4/13, 3/13)
print("Result for Manual solving from part 2:")
print("c(6/13, 4/13, 3/13)")
P <- matrix(c(0.5, 0.5, 0,
0.5, 0,   0.5,
1/3, 1/3, 1/3),
nrow = 3, byrow = TRUE)
calculate_pagerank <- function(P, beta) {
N <- nrow(P)
J <- matrix(1/N, nrow = N, ncol = N)
G <- beta * P + (1 - beta) * J
e <- eigen(t(G))
v <- Re(e$vectors[,1])
pageranks <- v / sum(v)
return(pageranks)}
# Case1 when Beta = 1
pr_beta_1 <- calculate_pagerank(P, 1)
print("PageRanks for Beta = 1:")
print(pr_beta_1)
# Case2 when Beta = 0.85
pr_beta_085 <- calculate_pagerank(P, 0.85)
print("PageRanks for Beta = 0.85:")
print(pr_beta_085)
# Verify against my result from part 2
manual_calc <- c(6/13, 4/13, 3/13)
print("Result for Manual solving from part 2:")
print((6/13, 4/13, 3/13))
P <- matrix(c(0.5, 0.5, 0,
0.5, 0,   0.5,
1/3, 1/3, 1/3),
nrow = 3, byrow = TRUE)
print(P)
calculate_pagerank <- function(P, beta) {
N <- nrow(P)
J <- matrix(1/N, nrow = N, ncol = N)
G <- beta * P + (1 - beta) * J
e <- eigen(t(G))
v <- Re(e$vectors[,1])
pageranks <- v / sum(v)
return(pageranks)}
# Case1 when Beta = 1
pr_beta_1 <- calculate_pagerank(P, 1)
print("PageRanks for Beta = 1:")
print(pr_beta_1)
# Case2 when Beta = 0.85
pr_beta_085 <- calculate_pagerank(P, 0.85)
print("PageRanks for Beta = 0.85:")
print(pr_beta_085)
# Verify against my result from Q2
manual_calc <- c(6/13, 4/13, 3/13)
print("Result from Q2:")
print(manual_calc)
P <- matrix(c(0.5, 0.5, 0,
0.5, 0,   0.5,
1/3, 1/3, 1/3),
nrow = 3, byrow = TRUE)
print(P)
calculate_pagerank_power <- function(P, beta) {
N <- nrow(P)
J <- matrix(1/N, nrow = N, ncol = N)
G <- beta * P + (1 - beta) * J
pi <- rep(1/N, N)
for(i in 1:1000) {
prev_pi <- pi
pi <- pi %*% G}
return(as.vector(pi))}
# Case1 when Beta = 1
pr_beta_1 <- calculate_pagerank(P, 1)
print("PageRanks for Beta = 1:")
print(pr_beta_1)
# Case2 when Beta = 0.85
pr_beta_085 <- calculate_pagerank(P, 0.85)
print("PageRanks for Beta = 0.85:")
print(pr_beta_085)
# Verify against my result from Q2
manual_calc <- c(6/13, 4/13, 3/13)
print("Result from Q2:")
print(manual_calc)
P <- matrix(c(0.5, 0.5, 0,
0.5, 0,   0.5,
1/3, 1/3, 1/3),
nrow = 3, byrow = TRUE)
print(P)
calculate_pagerank <- function(P, beta) {
N <- nrow(P)
J <- matrix(1/N, nrow = N, ncol = N)
G <- beta * P + (1 - beta) * J
pi <- rep(1/N, N)
for(i in 1:1000) {
prev_pi <- pi
pi <- pi %*% G}
return(as.vector(pi))
}
# Case1 when Beta = 1
pr_beta_1 <- calculate_pagerank(P, 1)
print("PageRanks for Beta = 1:")
print(pr_beta_1)
# Case2 when Beta = 0.85
pr_beta_085 <- calculate_pagerank(P, 0.85)
print("PageRanks for Beta = 0.85:")
print(pr_beta_085)
# Verify against my result from Q2
manual_calc <- c(6/13, 4/13, 3/13)
print("Result from Q2:")
print(manual_calc)
P <- matrix(c(1/2, 1/2, 0,
1/2, 0, 1/2,
1/3, 1/3,1/3),
nrow = 3, byrow = TRUE)
print(P)
# This is my function to find pagerank
calculate_pagerank <- function(P, beta) {
N <- nrow(P)
J <- matrix(1/N, nrow = N, ncol = N)
G <- beta * P + (1 - beta) * J
pi <- rep(1/N, N)
for(i in 1:1000) {
prev_pi <- pi
pi <- pi %*% G}
return(as.vector(pi))
}
# Case1 when Beta = 1
pr_beta_1 <- calculate_pagerank(P, 1)
print("PageRanks for Beta = 1:")
print(pr_beta_1)
# Case2 when Beta = 0.85
pr_beta_085 <- calculate_pagerank(P, 0.85)
print("PageRanks for Beta = 0.85:")
print(pr_beta_085)
# Verify against my result from Q2
manual_calc <- c(6/13, 4/13, 3/13)
print("Result from Q2:")
print(manual_calc)
setwd("~/UMass/Grad Files/DACSS-601/hw2")
rmarkdown:::convert_ipynb("Applying_Fun_R.ipynb")
# install.packages('rio')
# opening a file from a url (file in Excel), name it 'fragility23'
linkGit="https://github.com/FundamentalsRudraksh/hw2/raw/refs/heads/main/FSI-2023-DOWNLOAD.xlsx"
# library(rio) # package needed
fragility23=rio::import(file = linkGit) #object that will hold the result
str(fragility23)
# whole DF?
# sqrt(fragility23)
# several columns (only numerical)
sqrt(fragility23[,4:5])
# one column
sqrt(fragility23$Total)
# one value
sqrt(fragility23$Total[1])
# sum everything
sum(fragility23[,4:5])
# sum by column
print(apply(fragility23[,4:5],2,sum))
#notice
typeof(apply(fragility23[,4:5],2,sum))
# sum by row
print(apply(fragility23[,4:5],1,sum))
print(lapply(fragility23[,4:5],sum))
typeof(lapply(fragility23[,4:5],sum))
class(lapply(fragility23[,4:5],sum))
print(sapply(fragility23[,4:5],sum))
class(sapply(fragility23[,4:5],sum))
print(lapply(fragility23[,4:5],sqrt))
class(lapply(fragility23[,4:5],sqrt))
print(sapply(fragility23[,4:5],sqrt))
class(sapply(fragility23[,4:5],sqrt))
theOnesOK = function(DF_country_and_variable) {
variable_values <- DF_country_and_variable[,2]
avg_value <- mean(variable_values, na.rm = TRUE)
is_above <- ifelse(variable_values > avg_value, "Above Average", "Below/At Average")
DF_country_and_variable$Status <- is_above
return(DF_country_and_variable)
}
theOnesOK(fragility23[,c('Country','S1: Demographic Pressures')])
mystery=function(DF,positionsToUse,CountryColumn='Country'){
newDF=DF[,c(CountryColumn),drop = FALSE]
average='average'
newDF[,average]=apply(DF[,positionsToUse],1,mean,na.rm = TRUE)
return(newDF[,c(CountryColumn,average)])
}
mystery(fragility23,4:6)
install.packages("rio")
mystery=function(DF,positionsToUse,CountryColumn='Country'){ # Creates a function that calculates row wise average for certain columns
newDF=DF[,c(CountryColumn),drop = FALSE] # Creates a new dataframe which contains only the CountryColumn
average='average' #S
newDF[,average]=apply(DF[,positionsToUse],1,mean,na.rm = TRUE)
return(newDF[,c(CountryColumn,average)])
}
mystery=function(DF,positionsToUse,CountryColumn='Country'){ # Creates a function that calculates row wise average for certain columns
newDF=DF[,c(CountryColumn),drop = FALSE] # Creates a new dataframe which contains only the CountryColumn
average<-'average' #S
newDF[,average]=apply(DF[,positionsToUse],1,mean,na.rm = TRUE)
return(newDF[,c(CountryColumn,average)])
}
theOnesOK2 = function(DF, DFvariable, CountryColumn='Country') { # Creates a function that labels values as above average or below average
variable_values <- DF[,DFvariable] # Specify any column which contains the numeric value
avg_value <- mean(variable_values, na.rm = TRUE) # Calculates the mean of the above specified column. Ignore missing values
is_above <- ifelse(variable_values > avg_value, "Above Average", "Below/At Average")
newname = paste('Status_on', DFvariable)
DF[,newname] <- is_above
return(DF[,c(CountryColumn, newname)])
}
theOnesOK2(fragility23, "S1: Demographic Pressures")
mistery(fragility23, 4:6)
mistery = function(DF, positionsToUse, CountryColumn='Country'){ # Creates a function that calculates row wise average for the selected columns
newDF = DF[,c(CountryColumn), drop = FALSE] # creates a new data frame with only the Country columns
average = 'average' # Stores the name of the new column as a string called average
newDF[,average] = apply(DF[,positionsToUse], 1, mean, na.rm = TRUE) # Calculates the row wise average of the selected column and ignores missing values
return(newDF[,c(CountryColumn, average)]) # Returns a new dataframe as output which contains the Country and averge column
}
theOnesOK2(fragility23, "S1: Demographic Pressures")
mistery(fragility23, 4:6)
