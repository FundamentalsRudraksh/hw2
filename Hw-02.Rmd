---
title: An R Markdown document converted from "Applying_Fun_R.ipynb"
output: html_document
---

# Applying functions in R

Installing to tead Excel files:

```{r}
# install.packages('rio') #
```

# reading data

```{r}
# opens a file from the GIT url and name it 'fragility23'
linkGit="https://github.com/FundamentalsRudraksh/hw2/raw/refs/heads/main/FSI-2023-DOWNLOAD.xlsx"

# library(rio) # calls the package to be used
fragility23=rio::import(file = linkGit) #creates an object that will hold the result
```

```{r}
str(fragility23) # prints the structure of the dataset to see column names, data types etc
```

## Apply square root function?

```{r}
# whole DF?
# sqrt(fragility23) # this applies square root to the entire dataset but we are not using this as the data has non-numeric type as well
```

```{r}
# several columns (only numerical)

sqrt(fragility23[,4:5]) # Applies square root function to column 4 and column 5
```

```{r}
# one column
sqrt(fragility23$Total) # Applies square root function to the column named Total
```

```{r}
# one value
sqrt(fragility23$Total[1]) # Applies square root function to the first value of the Total column
```

## Applying **sum()**:

```{r}
# sum everything
sum(fragility23[,4:5]) # Calculates the sum of the respective values in column 4 and column 5
```

```{r}
# sum by column
print(apply(fragility23[,4:5],2,sum)) # Calculates the sum of column 4 and column 5 individually (separately)
```

```{r}
#notice
typeof(apply(fragility23[,4:5],2,sum)) # Checks the data type of the resulted generated by the sum in the previous case
```

If you do not see **list**, then it is a vector. ‚è´

```{r}
# sum by row
print(apply(fragility23[,4:5],1,sum)) # Calculates the sum row wise of column 4 and column 5
```

### Apply by iterating:

```{r}
print(lapply(fragility23[,4:5],sum)) # Calculates the sum of column 4 and column 5 individually and returns a list
```

Notice output of **lapply**:

```{r}
typeof(lapply(fragility23[,4:5],sum)) # checks the storage/ data type of the output of the previous part
```

```{r}
class(lapply(fragility23[,4:5],sum)) # Checks the class of the object/ output returned by lapply
```

Notice output of **sapply**:

```{r}
print(sapply(fragility23[,4:5],sum)) # Calculates the sum of column 4 and column 5 individually but returns a simplified result as compared to that of lapply
```

```{r}
class(sapply(fragility23[,4:5],sum)) # Checks the class of the object/ output returned by sapply
```

Similarly:

```{r}
print(lapply(fragility23[,4:5],sqrt)) # Applies the square root function to column 4 and column 5 and returns a list as output
```

```{r}
class(lapply(fragility23[,4:5],sqrt)) # Checks the class of the object/ output returned from the previous part
```

```{r}
print(sapply(fragility23[,4:5],sqrt)) # Applies square root function to column 4 and column 5 and returns a simplified output as compared to lapply
```

```{r}
class(sapply(fragility23[,4:5],sqrt)) # Checks the class of the object/ output returned from the previous part of sapply
```

Now our own function:

```{r}
theOnesOK = function(DF_country_and_variable) { # Creates a function that labels values as above average or below average
  variable_values <- DF_country_and_variable[,2] # Get the 2nd column from the data
  avg_value <- mean(variable_values, na.rm = TRUE) # Calculates the mean of the 2nd column. Ignores missing values
  is_above <- ifelse(variable_values > avg_value, "Above Average", "Below/At Average") # Compares each value to the mean and mark them as Above or Below Average
  DF_country_and_variable$Status <- is_above # Add the labels as a new column called Status
  return(DF_country_and_variable) # Returns the dataset with the new column
}
```

```{r}
theOnesOK(fragility23[,c('Country','S1: Demographic Pressures')]) # Apply theOnesOK function to Country and S1: Demographic Pressures
```

```{r}
mystery=function(DF,positionsToUse,CountryColumn='Country'){ # Creates a function that calculates row wise average for certain columns
  newDF=DF[,c(CountryColumn),drop = FALSE] # Creates a new dataframe which contains only the Country Column
  average='average' # Stores the name of new column like a string
  newDF[,average]=apply(DF[,positionsToUse],1,mean,na.rm = TRUE) # Calculates the row wise average. Ignores missing values
  return(newDF[,c(CountryColumn,average)]) # Returns the Country column and the average column
}
```

```{r}
mystery(fragility23,4:6) # Apply the mystery function using columns 4 to 6
```

# Part 2
## Exercise-01
```{r}
theOnesOK2 = function(DF, DFvariable, CountryColumn='Country') { # Creates a function that labels values as above average or below average
  variable_values <- DF[,DFvariable] # Specify any column which contains the numeric value
  avg_value <- mean(variable_values, na.rm = TRUE) # Calculates the mean of the above specified column. Ignore missing values
  is_above <- ifelse(variable_values > avg_value, "Above Average", "Below/At Average") # Compares each value to the mean and mark them as Above or Below Average
  newname = paste('Status_on', DFvariable) # Creates a new dynamic column based on the variable used
  DF[,newname] <- is_above # Add the new status column to the data
  return(DF[,c(CountryColumn, newname)]) # Returns the Country column and the new status column
}
```
theOnesOK2 function classifies each value (country) as Above or Below average based on whether the value in the numeric
column is greater than or less than the mean. It creates a dynamic column for status and returns the country column and the status column.
theOnesOK2 function works by first accepting a column from the user which contains numeric value. It then computes the mean
of the column given above while ignoring the missing values. Then it compares each country's value to the mean and labels them as above or below average. It then generates a new dynamic column based on the variable which was used and then this column is added to the data frame.
The difference between theOnesOK and theOnesOK2 is that the original theOnesOk function assumes that the numeric values are always in the 2nd column while theOnesOK2 allows the user to specify any column which makes it more flexible. The other differnce is that theOnesOK creates a column called Status and returns the entire dataset as result while theOnesOK2 creates a dynamic column based on the variable used and returns only the country and the status column.

## Exercise-02
```{r}
mistery = function(DF, positionsToUse, CountryColumn='Country'){ # Creates a function that calculates row wise average for the selected columns
  newDF = DF[,c(CountryColumn), drop = FALSE] # creates a new data frame with only the Country columns
  average = 'average' # Stores the name of the new column as a string called average
  newDF[,average] = apply(DF[,positionsToUse], 1, mean, na.rm = TRUE) # Calculates the row wise average of the selected column and ignores missing values
  return(newDF[,c(CountryColumn, average)]) # Returns a new dataframe as output which contains the Country and averge column
}
```
The mystery/ mistery function basically calculates the row wise mean/ average of the selected columns and returns a data frame which contains the column name and the average.
The function selects the Country column and stores it into a new data frame. It then creates a new column called average which would be used to store the average. Then the function uses the apply function with 1 to ensure that the mean is calculated row wise while ignoring the missing values. 
It finally returns a new data frame with two columns: country and average

# Outputs for the new functions
```{r}
theOnesOK2(fragility23, "S1: Demographic Pressures")
mistery(fragility23, 4:6)
```

